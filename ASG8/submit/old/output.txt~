sourav@ubuntu:~/Compilers/ASG8$ ./lalrparser <test.txt >output.txt 
Starting parse
Entering state 0
Reading a token: Next token is token GLOBAL ()
Shifting token GLOBAL ()
Entering state 1
//************************************************ staring the decilist part
Reading a token: Next token is token DEF ()
Shifting token DEF ()
//************************************************ got a DEF corresponding to "def // Definitions"
Entering state 3
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 7
Reading a token: Next token is token COLON ()
Reducing stack by rule 11 (line 82):
-> $$ = nterm sizeListO ()
//************************************************ sizeListO is gone 
Stack now 0 1 3 7
Entering state 30
Reducing stack by rule 10 (line 80):
   $1 = token ID ()
   $2 = nterm sizeListO ()
-> $$ = nterm var ()
Stack now 0 1 3
Entering state 10
Next token is token COLON ()
Reducing stack by rule 9 (line 77):
   $1 = nterm var ()
-> $$ = nterm varList ()
Stack now 0 1 3
Entering state 9
Next token is token COLON ()
Shifting token COLON ()
//************************************************ this is due to a":"int
Entering state 36
Reading a token: Next token is token INT ()
Shifting token INT ()
//************************************************ its the int
Entering state 67
Reducing stack by rule 15 (line 91):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 1 3 9 36
//************************************************ making "INT" to type
Entering state 70
Reading a token: Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
//************************************************ denotes end of the line a:int;
Entering state 104
Reducing stack by rule 6 (line 72):
   $1 = nterm varList ()
   $2 = token COLON ()
   $3 = nterm type ()
   $4 = token SEMICOLON ()
-> $$ = nterm typeList ()
Stack now 0 1 3
//************************************************ a:int; is reduced to typeList
Entering state 8
//************************************************ similarly start for b:int;
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 33
Reading a token: Next token is token COLON ()
Reducing stack by rule 11 (line 82):
-> $$ = nterm sizeListO ()
Stack now 0 1 3 8 33
Entering state 30
Reducing stack by rule 10 (line 80):
   $1 = token ID ()
   $2 = nterm sizeListO ()
-> $$ = nterm var ()
//************************************************ b is converted to var
Stack now 0 1 3 8
Entering state 10
Next token is token COLON ()
Reducing stack by rule 9 (line 77):
   $1 = nterm var ()
-> $$ = nterm varList ()
Stack now 0 1 3 8
Entering state 34
Next token is token COLON ()
Shifting token COLON ()
//************************************************ got the colon in b:int;
Entering state 65
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 67
Reducing stack by rule 15 (line 91):
   $1 = token INT ()
-> $$ = nterm type ()
//************************************************ INT <---type
Stack now 0 1 3 8 34 65
Entering state 103
Reading a token: Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
//************************************************ end of the line b:int;
Entering state 123
Reducing stack by rule 5 (line 71):
   $1 = nterm typeList ()
   $2 = nterm varList ()
   $3 = token COLON ()
   $4 = nterm type ()
   $5 = token SEMICOLON ()
-> $$ = nterm typeList ()
//************************************************ now a:int;b:int; are reduced to typeList
Stack now 0 1 3
Entering state 8
//************************************************ starting for sum:float;
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 33
Reading a token: Next token is token COLON ()
Reducing stack by rule 11 (line 82):
-> $$ = nterm sizeListO ()
Stack now 0 1 3 8 33
Entering state 30
Reducing stack by rule 10 (line 80):
   $1 = token ID ()
   $2 = nterm sizeListO ()
-> $$ = nterm var ()
Stack now 0 1 3 8
//************************************************ ID is reduced to var
Entering state 10
Next token is token COLON ()
Reducing stack by rule 9 (line 77):
   $1 = nterm var ()
-> $$ = nterm varList ()
Stack now 0 1 3 8
Entering state 34
Next token is token COLON ()
Shifting token COLON ()
//************************************************ got the colon in sum:float;
Entering state 65
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
//************************************************ got the type FLOAT
Entering state 66
Reducing stack by rule 16 (line 92):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0 1 3 8 34 65
Entering state 103
Reading a token: Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
//************************************************ got the semicolon of sum:float;
Entering state 123
Reducing stack by rule 5 (line 71):
   $1 = nterm typeList ()
   $2 = nterm varList ()
   $3 = token COLON ()
   $4 = nterm type ()
   $5 = token SEMICOLON ()
-> $$ = nterm typeList ()
Stack now 0 1 3
//************************************************ reducing a:int;b:int;sum:float; to typeList
//************************************************ starting for
                                                   point := product
                                                   xpos:float;
                                                   ypos:float;
//************************************************                                                    
Entering state 8
Reading a token: Next token is token ID ()
Shifting token ID ()
//************************************************ got 
Entering state 33
Reading a token: Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 64
//************************************************ got the assign in point:=product
Reading a token: Next token is token PRODUCT ()
Shifting token PRODUCT ()
//************************************************ got the keyword product
Entering state 102
Reading a token: Next token is token ID ()
Shifting token ID ()
//************************************************ xpos
Entering state 7
Reading a token: Next token is token COLON ()
Reducing stack by rule 11 (line 82):
-> $$ = nterm sizeListO ()
Stack now 0 1 3 8 33 64 102 7
Entering state 30
Reducing stack by rule 10 (line 80):
   $1 = token ID ()
   $2 = nterm sizeListO ()
-> $$ = nterm var ()
Stack now 0 1 3 8 33 64 102
Entering state 10
Next token is token COLON ()
Reducing stack by rule 9 (line 77):
   $1 = nterm var ()
-> $$ = nterm varList ()
//************************************************ var is reduced to varlist
Stack now 0 1 3 8 33 64 102
Entering state 9
Next token is token COLON ()
Shifting token COLON ()
//************************************************ got : in xpos:float;
Entering state 36
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
//************************************************ got the float in xpos:float;
Entering state 66
Reducing stack by rule 16 (line 92):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0 1 3 8 33 64 102 9 36
Entering state 70
Reading a token: Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
//************************************************ got the end semicolon of xpos:float;
Entering state 104
Reducing stack by rule 6 (line 72):
   $1 = nterm varList ()
   $2 = token COLON ()
   $3 = nterm type ()
   $4 = token SEMICOLON ()
-> $$ = nterm typeList ()
//************************************************ reducing xpos:float to typeList
Stack now 0 1 3 8 33 64 102
Entering state 122
Reading a token: Next token is token ID ()
Shifting token ID ()
//************************************************ got ypos of ypos:float;
Entering state 33
Reading a token: Next token is token COLON ()
Reducing stack by rule 11 (line 82):
-> $$ = nterm sizeListO ()
Stack now 0 1 3 8 33 64 102 122 33
Entering state 30
Reducing stack by rule 10 (line 80):
   $1 = token ID ()
   $2 = nterm sizeListO ()
-> $$ = nterm var ()
Stack now 0 1 3 8 33 64 102 122
Entering state 10
Next token is token COLON ()
Reducing stack by rule 9 (line 77):
   $1 = nterm var ()
-> $$ = nterm varList ()
//************************************************ var to varlist
Stack now 0 1 3 8 33 64 102 122
Entering state 34
Next token is token COLON ()
Shifting token COLON ()
//************************************************ got : in ypos:float;
Entering state 65
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
//************************************************ got float in ypos:float;
Entering state 66
Reducing stack by rule 16 (line 92):
   $1 = token FLOAT ()
-> $$ = nterm type ()
//************************************************ float is reduced to type
Stack now 0 1 3 8 33 64 102 122 34 65
Entering state 103
Reading a token: Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
//************************************************ got the end ; of ypos:float;
Entering state 123
Reducing stack by rule 5 (line 71):
   $1 = nterm typeList ()
   $2 = nterm varList ()
   $3 = token COLON ()
   $4 = nterm type ()
   $5 = token SEMICOLON ()
-> $$ = nterm typeList ()
//************************************************ xpos:float;ypost:float; is reduced to typelist 
Stack now 0 1 3 8 33 64 102
Entering state 122
Reading a token: Next token is token END ()
Shifting token END ()
Entering state 131
Reducing stack by rule 19 (line 97):
   $1 = token ID ()
   $2 = token ASSIGN ()
   $3 = token PRODUCT ()
   $4 = nterm typeList ()
   $5 = token END ()
-> $$ = nterm typeDef ()
Stack now 0 1 3 8
Entering state 35
//************************************************ 
                                                   point := product
                                                   xpos:float;
                                                   ypos:float;

                                                   is reduced to typeDef 
Reducing stack by rule 7 (line 73):
   $1 = nterm typeList ()
   $2 = nterm typeDef ()
-> $$ = nterm typeList ()
//************************************************ previous typelist and the new typedef are reduced to a single typeList
Stack now 0 1 3
Entering state 8
Reading a token: Next token is token END ()
Shifting token END ()
Entering state 32
Reducing stack by rule 4 (line 69):
   $1 = token DEF ()
   $2 = nterm typeList ()
   $3 = token END ()
-> $$ = nterm decl ()
//************************************************ the decl part is over. as the whole declaration part is parsed
                           ie def // Definitions
                              a:int;
                              b:int;
                              sum:float;
                              point := product
                                 xpos:float;
                                 ypos:float;
                              end
                           end
                           is parsed to decl
Stack now 0 1
Entering state 5
Reading a token: Next token is token ID ()
Reducing stack by rule 2 (line 64):
-> $$ = nterm declList ()
Stack now 0 1 5
Entering state 28
Reducing stack by rule 3 (line 66):
   $1 = nterm decl ()
   $2 = nterm declList ()
-> $$ = nterm declList ()
Stack now 0 1
Entering state 4
//************************************************ decl is parsed to declList

//************************************************ now the stmlListO is going to be created ,,, i e the rest of the program
                                                   upto the very last end 
Next token is token ID ()
Shifting token ID ()
//************************************************ got a in a:=1;
Entering state 16
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ reduced ID to id
Stack now 0 1 4
Entering state 27
Next token is token ASSIGN ()
Reducing stack by rule 31 (line 117):
   $1 = nterm id ()
-> $$ = nterm dotId ()
//************************************************ reduce id to dotid
Stack now 0 1 4
Entering state 21
Next token is token ASSIGN ()
Shifting token ASSIGN ()
//************************************************ get thr := in a:=1;
Entering state 57
Reading a token: Next token is token ID ()
Shifting token ID ()
//************************************************ got the id='1'
Entering state 16
Reading a token: Next token is token SEMICOLON ()
//************************************************ got the end of the line a:=1;
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 21 57 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ '1' is reduced to id
Stack now 0 1 4 21 57
Entering state 42
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
//************************************************ id is reduced to exp
Stack now 0 1 4 21 57
Entering state 98
Next token is token SEMICOLON ()
Reducing stack by rule 30 (line 114):
   $1 = nterm dotId ()
   $2 = token ASSIGN ()
   $3 = nterm exp ()
-> $$ = nterm assignmentStmt ()
//************************************************ a:=1 is reduced to an assignmentStmt
Stack now 0 1 4
Entering state 20
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
//************************************************ ; at the end of a:=1 is shifted
Entering state 56
Reducing stack by rule 24 (line 106):
   $1 = nterm assignmentStmt ()
   $2 = token SEMICOLON ()
-> $$ = nterm stmt ()
Stack now 0 1 4
//************************************************ whole a:=1 is reduced to stmt
Entering state 19
Reducing stack by rule 23 (line 104):
   $1 = nterm stmt ()
-> $$ = nterm stmtList ()
//************************************************ stmt is converted to stmtList
Stack now 0 1 4
Entering state 18
//************************************************ beginning the next line sum:=1.0;
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 16
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
Stack now 0 1 4 18
Entering state 27
Next token is token ASSIGN ()
Reducing stack by rule 31 (line 117):
   $1 = nterm id ()
-> $$ = nterm dotId ()
Stack now 0 1 4 18
Entering state 21
//************************************************ sum is reduced to dotId
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 57
Reading a token: Next token is token FLOAT_CONST ()
Shifting token FLOAT_CONST ()
//************************************************ we got 1.0
Entering state 41
Reducing stack by rule 68 (line 180):
   $1 = token FLOAT_CONST ()
-> $$ = nterm exp ()
Stack now 0 1 4 18 21 57
//************************************************ redufing 1.0 to exp
Entering state 98
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 30 (line 114):
   $1 = nterm dotId ()
   $2 = token ASSIGN ()
   $3 = nterm exp ()
-> $$ = nterm assignmentStmt ()
//************************************************ reduced it to assignmentStmt
Stack now 0 1 4 18
Entering state 20
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
//************************************************ got the ; of sum:=1.0;
Entering state 56
Reducing stack by rule 24 (line 106):
   $1 = nterm assignmentStmt ()
   $2 = token SEMICOLON ()
-> $$ = nterm stmt ()
//************************************************ reduced it to stmt
Stack now 0 1 4 18
Entering state 55
Reducing stack by rule 22 (line 103):
   $1 = nterm stmtList ()
   $2 = nterm stmt ()
-> $$ = nterm stmtList ()
//************************************************ reducing all stmt lines to stmtList
//************************************************ preparing for point.xpos:=2.331
Stack now 0 1 4
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
//************************************************ got point
Entering state 16
Reading a token: Next token is token DOT ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ point to id
Stack now 0 1 4 18
Entering state 27
Next token is token DOT ()
Shifting token DOT ()
//************************************************ got .
Entering state 61
Reading a token: Next token is token ID ()
Shifting token ID ()
//************************************************ got xpos
Entering state 16
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 27 61 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ xpos to id
Stack now 0 1 4 18 27 61
Entering state 27
Next token is token ASSIGN ()
Reducing stack by rule 31 (line 117):
   $1 = nterm id ()
-> $$ = nterm dotId ()
//************************************************ xpos to dotId
Stack now 0 1 4 18 27 61
Entering state 99
Reducing stack by rule 32 (line 118):
   $1 = nterm id ()
   $2 = token DOT ()
   $3 = nterm dotId ()
-> $$ = nterm dotId ()
//************************************************ point.xpos to dotId
Stack now 0 1 4 18
Entering state 21
Next token is token ASSIGN ()
Shifting token ASSIGN ()
//************************************************ got the :=
Entering state 57
Reading a token: Next token is token FLOAT_CONST ()
Shifting token FLOAT_CONST ()
Entering state 41
Reducing stack by rule 68 (line 180):
   $1 = token FLOAT_CONST ()
-> $$ = nterm exp ()
//************************************************ getting the float 2.331 and converting it to exp
Stack now 0 1 4 18 21 57
Entering state 98
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 30 (line 114):
   $1 = nterm dotId ()
   $2 = token ASSIGN ()
   $3 = nterm exp ()
-> $$ = nterm assignmentStmt ()
//************************************************ reduce the line point.xpos:=2.331 to assignmentstmt
Stack now 0 1 4 18
Entering state 20
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 24 (line 106):
   $1 = nterm assignmentStmt ()
   $2 = token SEMICOLON ()
-> $$ = nterm stmt ()
//************************************************ reducing assignmentstmt to stmt
Stack now 0 1 4 18
Entering state 55
Reducing stack by rule 22 (line 103):
   $1 = nterm stmtList ()
   $2 = nterm stmt ()
-> $$ = nterm stmtList ()
Stack now 0 1 4
//************************************************ reduce all statement upto now to stmtList
//************************************************ going to parse point.ypos=sum+a;
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 16
//************************************************ got point
Reading a token: Next token is token DOT ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ change point to id
Stack now 0 1 4 18
Entering state 27
Next token is token DOT ()
Shifting token DOT ()
//************************************************ got the . in point.ypos
Entering state 61
Reading a token: Next token is token ID ()
Shifting token ID ()
//************************************************ got the ypos
Entering state 16
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 27 61 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
Stack now 0 1 4 18 27 61
Entering state 27
//************************************************ got ypos to id
Next token is token ASSIGN ()
Reducing stack by rule 31 (line 117):
   $1 = nterm id ()
-> $$ = nterm dotId ()
Stack now 0 1 4 18 27 61
Entering state 99
//************************************************ ypos to dotId
Reducing stack by rule 32 (line 118):
   $1 = nterm id ()
   $2 = token DOT ()
   $3 = nterm dotId ()
-> $$ = nterm dotId ()
Stack now 0 1 4 18
Entering state 21
//************************************************ point.ypos to dotId
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 57
//************************************************ got the :=
Reading a token: Next token is token ID ()
Shifting token ID ()
//************************************************ got sum
Entering state 16
Reading a token: Next token is token PLUS ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 21 57 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ sum to id
Stack now 0 1 4 18 21 57
Entering state 42
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
//************************************************ sum to exp
Stack now 0 1 4 18 21 57
Entering state 98
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 89
//************************************************ got + in sum+a
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 16
//************************************************ got a
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 21 57 98 89 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ a to id
Stack now 0 1 4 18 21 57 98 89
Entering state 42
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
//************************************************ a to exp
Stack now 0 1 4 18 21 57 98 89
Entering state 115
Next token is token SEMICOLON ()
Reducing stack by rule 58 (line 170):
   $1 = nterm exp ()
   $2 = token PLUS ()
   $3 = nterm exp ()
-> $$ = nterm exp ()
Stack now 0 1 4 18 21 57
Entering state 98
//************************************************ sum+a to exp
Next token is token SEMICOLON ()
Reducing stack by rule 30 (line 114):
   $1 = nterm dotId ()
   $2 = token ASSIGN ()
   $3 = nterm exp ()
-> $$ = nterm assignmentStmt ()
//************************************************ point.ypos:=sum+a to assignmentstmt
Stack now 0 1 4 18
Entering state 20
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 24 (line 106):
   $1 = nterm assignmentStmt ()
   $2 = token SEMICOLON ()
-> $$ = nterm stmt ()
//************************************************ assignmentstmt; to ie point.ypos:=sum+a to stmt
Stack now 0 1 4 18
Entering state 55
Reducing stack by rule 22 (line 103):
   $1 = nterm stmtList ()
   $2 = nterm stmt ()
-> $$ = nterm stmtList ()
Stack now 0 1 4
Entering state 18
//************************************************ all statement upto now to stmtList
//************************************************ going to parse read %d b;
Reading a token: Next token is token READ ()
Shifting token READ ()
Entering state 13
//************************************************ got read
Reading a token: Next token is token FORMAT ()
Shifting token FORMAT ()
Entering state 46
//************************************************ got %d as format
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 16
//************************************************ got b
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 13 46 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ b to id
Stack now 0 1 4 18 13 46
Entering state 42
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
Stack now 0 1 4 18 13 46
Entering state 93
//************************************************ b to exp
Next token is token SEMICOLON ()
Reducing stack by rule 33 (line 121):
   $1 = token READ ()
   $2 = token FORMAT ()
   $3 = nterm exp ()
-> $$ = nterm readStmt ()
//************************************************ read %d b to readStmt
Stack now 0 1 4 18
Entering state 22
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 58
//************************************************ getting ;
Reducing stack by rule 25 (line 107):
   $1 = nterm readStmt ()
   $2 = token SEMICOLON ()
-> $$ = nterm stmt ()
Stack now 0 1 4 18
Entering state 55
//************************************************ read %d b; to stmt
Reducing stack by rule 22 (line 103):
   $1 = nterm stmtList ()
   $2 = nterm stmt ()
-> $$ = nterm stmtList ()
Stack now 0 1 4
Entering state 18
//************************************************ all statements upto now to stmtList
//************************************************ if b=0:
Reading a token: Next token is token IF ()
Shifting token IF ()
Entering state 11
//************************************************ got if
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 16
//************************************************ got b
Reading a token: Next token is token EQ ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 11 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ b to id
Stack now 0 1 4 18 11
Entering state 42
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
//************************************************ b to expr
Stack now 0 1 4 18 11
Entering state 44
Next token is token EQ ()
Shifting token EQ ()
//************************************************ got =
Entering state 80
Reducing stack by rule 52 (line 162):
   $1 = token EQ ()
-> $$ = nterm relOP ()
//************************************************ = to relOP
Stack now 0 1 4 18 11 44
Entering state 91
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 16
//************************************************ got 0
Reading a token: Next token is token COLON ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 11 44 91 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ 0 to id
Stack now 0 1 4 18 11 44 91
Entering state 42
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
Stack now 0 1 4 18 11 44 91
Entering state 117
//************************************************ id 0 to exp
Next token is token COLON ()
Reducing stack by rule 51 (line 159):
   $1 = nterm exp ()
   $2 = nterm relOP ()
   $3 = nterm exp ()
-> $$ = nterm bExp ()
Stack now 0 1 4 18 11
Entering state 43
//************************************************ b=0 to bExp
Next token is token COLON ()
Shifting token COLON ()
Entering state 77
//************************************************ the : of if b=0:
//************************************************ gettign the stmtList of the if
//************************************************ to get print %f point.xpos;
Reading a token: Next token is token PRINT ()
Shifting token PRINT ()
Entering state 12
//************************************************ got print
Reading a token: Next token is token FORMAT ()
Shifting token FORMAT ()
Entering state 45
//************************************************ got %f
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 16
//************************************************ got ID = point
Reading a token: Next token is token DOT ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 11 43 77 12 45 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ point to id
Stack now 0 1 4 18 11 43 77 12 45
Entering state 42
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
//************************************************ point to exp
Stack now 0 1 4 18 11 43 77 12 45
Entering state 92
Next token is token DOT ()
Shifting token DOT ()
Entering state 90
//************************************************ got . point.xpos
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 16
//************************************************ got xpos
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 11 43 77 12 45 92 90 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ xpos to id
Stack now 0 1 4 18 11 43 77 12 45 92 90
Entering state 42
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
//************************************************ xpos to exp
Stack now 0 1 4 18 11 43 77 12 45 92 90
Entering state 116
Next token is token SEMICOLON ()
Reducing stack by rule 63 (line 175):
   $1 = nterm exp ()
   $2 = token DOT ()
   $3 = nterm exp ()
-> $$ = nterm exp ()
Stack now 0 1 4 18 11 43 77 12 45
Entering state 92
//************************************************ make point.xpos to exp
Next token is token SEMICOLON ()
Reducing stack by rule 34 (line 124):
   $1 = token PRINT ()
   $2 = token FORMAT ()
   $3 = nterm exp ()
-> $$ = nterm printStmt ()
//************************************************ print %f point.xpos; to printStmt
Stack now 0 1 4 18 11 43 77
Entering state 23
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 59
Reducing stack by rule 26 (line 108):
   $1 = nterm printStmt ()
   $2 = token SEMICOLON ()
-> $$ = nterm stmt ()
//************************************************ reduce the line to stmt
Stack now 0 1 4 18 11 43 77
Entering state 19
Reducing stack by rule 23 (line 104):
   $1 = nterm stmt ()
-> $$ = nterm stmtList ()
Stack now 0 1 4 18 11 43 77
Entering state 109
//************************************************ convert line to stmtList
//************************************************ the ELSE part of the ifstmt
Reading a token: Next token is token ELSE ()
Shifting token ELSE ()
Entering state 127
//************************************************ got else
Reading a token: Next token is token PRINT ()
Shifting token PRINT ()
Entering state 12
//************************************************ got print
Reading a token: Next token is token FORMAT ()
Shifting token FORMAT ()
Entering state 45
//************************************************ got fromat = %f
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 16
//************************************************ got ID = point
Reading a token: Next token is token DOT ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 11 43 77 109 127 12 45 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ point to id
Stack now 0 1 4 18 11 43 77 109 127 12 45
Entering state 42
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
//************************************************ point to exp
Stack now 0 1 4 18 11 43 77 109 127 12 45
Entering state 92
Next token is token DOT ()
Shifting token DOT ()
Entering state 90
//************************************************ got the . is point.ypos
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 16
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 43 (line 146):
//************************************************ got ypos
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 11 43 77 109 127 12 45 92 90 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
Stack now 0 1 4 18 11 43 77 109 127 12 45 92 90
Entering state 42
//************************************************ ypos to id
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
//************************************************ id to exp
Stack now 0 1 4 18 11 43 77 109 127 12 45 92 90
Entering state 116
Next token is token SEMICOLON ()
Reducing stack by rule 63 (line 175):
   $1 = nterm exp ()
   $2 = token DOT ()
   $3 = nterm exp ()
-> $$ = nterm exp ()
//************************************************ point.ypos to exp
Stack now 0 1 4 18 11 43 77 109 127 12 45
Entering state 92
Next token is token SEMICOLON ()
Reducing stack by rule 34 (line 124):
   $1 = token PRINT ()
   $2 = token FORMAT ()
   $3 = nterm exp ()
-> $$ = nterm printStmt ()
//************************************************ print %f point.ypos to printStmt
Stack now 0 1 4 18 11 43 77 109 127
Entering state 23
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 59
Reducing stack by rule 26 (line 108):
   $1 = nterm printStmt ()
   $2 = token SEMICOLON ()
-> $$ = nterm stmt ()
//************************************************ got the whole statement with ; to stmt
Stack now 0 1 4 18 11 43 77 109 127
Entering state 19
Reducing stack by rule 23 (line 104):
   $1 = nterm stmt ()
-> $$ = nterm stmtList ()
//************************************************ the stmt to stmtList of ELSE part
Stack now 0 1 4 18 11 43 77 109 127
Entering state 134
Reading a token: Next token is token END ()
Reducing stack by rule 37 (line 131):
   $1 = token ELSE ()
   $2 = nterm stmtList ()
-> $$ = nterm elsePart ()
//************************************************ got the elsePart
Stack now 0 1 4 18 11 43 77 109
Entering state 128
Next token is token END ()
Shifting token END ()
Entering state 135
//************************************************ getting the end of the if block
Reducing stack by rule 35 (line 127):
   $1 = token IF ()
   $2 = nterm bExp ()
   $3 = token COLON ()
   $4 = nterm stmtList ()
   $5 = nterm elsePart ()
   $6 = token END ()
-> $$ = nterm ifStmt ()
//************************************************ making it to ifStmt
Stack now 0 1 4 18
Entering state 24
Reducing stack by rule 27 (line 109):
   $1 = nterm ifStmt ()
-> $$ = nterm stmt ()
//************************************************ making the if block to stmt
Stack now 0 1 4 18
Entering state 55
Reducing stack by rule 22 (line 103):
   $1 = nterm stmtList ()
   $2 = nterm stmt ()
-> $$ = nterm stmtList ()
Stack now 0 1 4
Entering state 18
//************************************************ all statement upto now to stmtList
//************************************************ starting the while block
Reading a token: Next token is token WHILE ()
Shifting token WHILE ()
Entering state 15
//************************************************ got while
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 16
//************************************************ got a
Reading a token: Next token is token LT ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 15 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ a to id
Stack now 0 1 4 18 15
Entering state 42
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
//************************************************ a to exp
Stack now 0 1 4 18 15
Entering state 44
Next token is token LT ()
Shifting token LT ()
Entering state 84
Reducing stack by rule 54 (line 164):
   $1 = token LT ()
-> $$ = nterm relOP ()
//************************************************ less than to relOP
Stack now 0 1 4 18 15 44
Entering state 91
Reading a token: Next token is token ID ()
Shifting token ID ()
//************************************************ got b
Entering state 16
Reading a token: Next token is token COLON ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 15 44 91 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ b to id
Stack now 0 1 4 18 15 44 91
Entering state 42
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
//************************************************ b to exp
Stack now 0 1 4 18 15 44 91
Entering state 117
Next token is token COLON ()
Reducing stack by rule 51 (line 159):
   $1 = nterm exp ()
   $2 = nterm relOP ()
   $3 = nterm exp ()
-> $$ = nterm bExp ()
//************************************************  a<b to bExp
Stack now 0 1 4 18 15
Entering state 50
Next token is token COLON ()
Shifting token COLON ()
Entering state 95
//************************************************ getting the : of while a<b :
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 16
//************************************************ getting a
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 15 50 95 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
Stack now 0 1 4 18 15 50 95
Entering state 27
//************************************************ a to id
Next token is token ASSIGN ()
Reducing stack by rule 31 (line 117):
   $1 = nterm id ()
-> $$ = nterm dotId ()
Stack now 0 1 4 18 15 50 95
Entering state 21
//************************************************ a to dotId
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 57
//************************************************ got the := from a:=a*2;
Reading a token: Next token is token ID ()
Shifting token ID ()
//************************************************ got ID = a
Entering state 16
Reading a token: Next token is token MULT ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 15 50 95 21 57 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ a to id
Stack now 0 1 4 18 15 50 95 21 57
Entering state 42
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
Stack now 0 1 4 18 15 50 95 21 57
Entering state 98
//************************************************ a to exp
Next token is token MULT ()
Shifting token MULT ()
Entering state 87
//************************************************ got the *
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 16
//************************************************ got ID =2
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 15 50 95 21 57 98 87 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ 2 to id
Stack now 0 1 4 18 15 50 95 21 57 98 87
Entering state 42
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
//************************************************ 2 to id to exp
Stack now 0 1 4 18 15 50 95 21 57 98 87
Entering state 114
Next token is token SEMICOLON ()
Reducing stack by rule 60 (line 172):
   $1 = nterm exp ()
   $2 = token MULT ()
   $3 = nterm exp ()
-> $$ = nterm exp ()
Stack now 0 1 4 18 15 50 95 21 57
Entering state 98
//************************************************ a*2 to exp
Next token is token SEMICOLON ()
Reducing stack by rule 30 (line 114):
   $1 = nterm dotId ()
   $2 = token ASSIGN ()
   $3 = nterm exp ()
-> $$ = nterm assignmentStmt ()
Stack now 0 1 4 18 15 50 95
Entering state 20
//************************************************ a:=a*2 to assignmentstmt
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 24 (line 106):
   $1 = nterm assignmentStmt ()
   $2 = token SEMICOLON ()
-> $$ = nterm stmt ()
Stack now 0 1 4 18 15 50 95
Entering state 19
//************************************************ a:=a*2; to stmt
Reducing stack by rule 23 (line 104):
   $1 = nterm stmt ()
-> $$ = nterm stmtList ()
Stack now 0 1 4 18 15 50 95
Entering state 118
//************************************************ stmt to stmtList
//************************************************ going to parse sum:=sum+1;
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 16
//************************************************ got the fisrt sum
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 15 50 95 118 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
Stack now 0 1 4 18 15 50 95 118
Entering state 27
Next token is token ASSIGN ()
Reducing stack by rule 31 (line 117):
   $1 = nterm id ()
-> $$ = nterm dotId ()
Stack now 0 1 4 18 15 50 95 118
Entering state 21
//************************************************ sum to dotId
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 57
//************************************************ got the :=
Reading a token: Next token is token ID ()
Shifting token ID ()
//************************************************ getting the next sum
Entering state 16
Reading a token: Next token is token PLUS ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 15 50 95 118 21 57 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
Stack now 0 1 4 18 15 50 95 118 21 57
Entering state 42
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
//************************************************ sum to exp
Stack now 0 1 4 18 15 50 95 118 21 57
Entering state 98
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 89
//************************************************ got +
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 16
//************************************************ got 1
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 15 50 95 118 21 57 98 89 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ 1 to id
Stack now 0 1 4 18 15 50 95 118 21 57 98 89
Entering state 42
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
//************************************************ id to exp
Stack now 0 1 4 18 15 50 95 118 21 57 98 89
Entering state 115
Next token is token SEMICOLON ()
Reducing stack by rule 58 (line 170):
   $1 = nterm exp ()
   $2 = token PLUS ()
   $3 = nterm exp ()
-> $$ = nterm exp ()
Stack now 0 1 4 18 15 50 95 118 21 57
Entering state 98
//************************************************ sum+1 to exp
Next token is token SEMICOLON ()
Reducing stack by rule 30 (line 114):
   $1 = nterm dotId ()
   $2 = token ASSIGN ()
   $3 = nterm exp ()
-> $$ = nterm assignmentStmt ()
//************************************************ sum=sum+1 to assignmentstmt
Stack now 0 1 4 18 15 50 95 118
Entering state 20
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 24 (line 106):
   $1 = nterm assignmentStmt ()
   $2 = token SEMICOLON ()
-> $$ = nterm stmt ()
//************************************************ sum=sum+1; to stmt
Stack now 0 1 4 18 15 50 95 118
Entering state 55
Reducing stack by rule 22 (line 103):
   $1 = nterm stmtList ()
   $2 = nterm stmt ()
-> $$ = nterm stmtList ()
Stack now 0 1 4 18 15 50 95
Entering state 118
//************************************************ all statements within while to stmtList
Reading a token: Next token is token END ()
Shifting token END ()
Entering state 129
Reducing stack by rule 38 (line 134):
   $1 = token WHILE ()
   $2 = nterm bExp ()
   $3 = token COLON ()
   $4 = nterm stmtList ()
   $5 = token END ()
-> $$ = nterm whileStmt ()
Stack now 0 1 4 18
Entering state 25
//************************************************ converting the while block to whileStmt
Reducing stack by rule 28 (line 110):
   $1 = nterm whileStmt ()
-> $$ = nterm stmt ()
Stack now 0 1 4 18
Entering state 55
//************************************************ whileStmt to stmt
Reducing stack by rule 22 (line 103):
   $1 = nterm stmtList ()
   $2 = nterm stmt ()
-> $$ = nterm stmtList ()
Stack now 0 1 4
Entering state 18
//************************************************ all stmt upto now to stmtList
//************************************************ return sum;
Reading a token: Next token is token RETURN ()
Shifting token RETURN ()
Entering state 14
//************************************************ got return
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 16
//************************************************ got ID = sum
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 43 (line 146):
-> $$ = nterm indexListO ()
Stack now 0 1 4 18 14 16
Entering state 52
Reducing stack by rule 42 (line 144):
   $1 = token ID ()
   $2 = nterm indexListO ()
-> $$ = nterm id ()
//************************************************ sum to ID
Stack now 0 1 4 18 14
Entering state 42
Reducing stack by rule 65 (line 177):
   $1 = nterm id ()
-> $$ = nterm exp ()
Stack now 0 1 4 18 14
Entering state 49
//************************************************ sum to exp
Next token is token SEMICOLON ()
Reducing stack by rule 41 (line 141):
   $1 = nterm exp ()
-> $$ = nterm expO ()
Stack now 0 1 4 18 14
Entering state 48
//************************************************ exp to expO
Reducing stack by rule 39 (line 137):
   $1 = token RETURN ()
   $2 = nterm expO ()
-> $$ = nterm returnStmt ()
Stack now 0 1 4 18
Entering state 26
//************************************************ return sum to returnStmt
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 60
Reducing stack by rule 29 (line 111):
   $1 = nterm returnStmt ()
   $2 = token SEMICOLON ()
-> $$ = nterm stmt ()
Stack now 0 1 4 18
Entering state 55
//************************************************ return sum; to returnStmt
Reducing stack by rule 22 (line 103):
   $1 = nterm stmtList ()
   $2 = nterm stmt ()
-> $$ = nterm stmtList ()
Stack now 0 1 4
Entering state 18
//************************************************ all stmt upto now to stmtList
Reading a token: Next token is token END ()
//************************************************ the very last end ,,, end of prog reached
Reducing stack by rule 21 (line 101):
   $1 = nterm stmtList ()
-> $$ = nterm stmtListO ()
Stack now 0 1 4
Entering state 17
//************************************************ the whole stmtList to stmtListO
Next token is token END ()
Shifting token END ()
Entering state 54
//************************************************ getting the very last END
Reducing stack by rule 1 (line 62):
   $1 = token GLOBAL ()
   $2 = nterm declList ()
   $3 = nterm stmtListO ()
   $4 = token END ()
-> $$ = nterm prog ()
Stack now 0
Entering state 2
//************************************************ reduce the whole program to prog
Reading a token: Now at end of input.
Shifting token $end ()
Entering state 6
Stack now 0 2 6
Cleanup: popping token $end ()
Cleanup: popping nterm prog ()
//************************************************ parsing complete